THREE.RipplesShader = {
    uniforms: {
        "noiseTime": { type: "f", value: 1 },
        "noiseSize": { type: "f", value: 2 },
        "lineTime": { type: "f", value: 1 },
        "lineCount": { type: "f", value: 40 },
        "dotSize": { type: "f", value: .3 },
        "lineSize": { type: "f", value: .1 },
        "blur": { type: "f", value: .05 },
        "depth": { type: "f", value: 300 },
        "opacity": { type: "f", value: 1 }
    },

    vertexShader: [
			"varying vec2 vUv;",
			"varying float vNoiseDisp;",
			"uniform float noiseTime;",
			"uniform float noiseSize;",
			"uniform float depth;",
			"vec3 mod289(vec3 x) {",
			"return x - floor(x * (1.0 / 289.0)) * 289.0;",
			"}",
			"vec2 mod289(vec2 x) {",
			"return x - floor(x * (1.0 / 289.0)) * 289.0;",
			"}",
			"vec3 permute(vec3 x) {",
			"return mod289(((x*34.0)+1.0)*x);",
			"}",
			"float snoise(vec2 v) {",
			"const vec4 C = vec4(0.211324865405187,",
			"				  0.366025403784439,",
			"				 -0.577350269189626,",
			"				  0.024390243902439);",
			"vec2 i  = floor(v + dot(v, C.yy) );",
			"vec2 x0 = v -   i + dot(i, C.xx);",
			"vec2 i1;", "i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);",
			"vec4 x12 = x0.xyxy + C.xxzz;",
			"x12.xy -= i1;",
			"i = mod289(i); // Avoid truncation effects in permutation",
			"vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))",
			"	+ i.x + vec3(0.0, i1.x, 1.0 ));",
			"vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);",
			"m = m*m ;",
			"m = m*m ;",
			"vec3 x = 2.0 * fract(p * C.www) - 1.0;",
			"vec3 h = abs(x) - 0.5;",
			"vec3 ox = floor(x + 0.5);",
			"vec3 a0 = x - ox;",
			"m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );",
			"vec3 g;",
			"g.x  = a0.x  * x0.x  + h.x  * x0.y;",
			"g.yz = a0.yz * x12.xz + h.yz * x12.yw;",
			"return 130.0 * dot(m, g);",
			"}", "void main() {",
			"vUv = uv;",
			"vNoiseDisp = snoise(vUv*noiseSize + noiseTime) ;",
			"vec3 newPosition = position + normal * vNoiseDisp *depth;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );",
			"}"

		].join("\n"),


		fragmentShader: [
			"const vec3 black = vec3(0.0, 0.0, 0.0);",
			"uniform float lineTime;",
			"uniform float noiseTime;",
			"uniform float lineCount;",
			"uniform float dotSize;",
			"uniform float lineSize;",
			"uniform float blur;",
			"uniform float opacity;",
			"varying vec2 vUv;",
			"varying float vNoiseDisp;",
			"vec3 hsv2rgb(vec3 c){",
			"vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);",
			"vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);",
			"return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);",
			"}",
			"void main() {",
			"vec3 c = hsv2rgb(vec3(vUv.x + noiseTime, 0.8, 0.7));",
			"vec2 p = vUv;",
			"p.y += lineTime;",
			"vec2 nearest = 2.0*fract(lineCount * p) - 1.0;",
			"float dist = length(nearest);",
			"vec3 dotcol = mix(c, black, smoothstep(dotSize, dotSize + dotSize*blur, dist));",
			"float x = fract(p.y * lineCount) - .5 + lineSize/2.;",
			"float f = smoothstep(-lineSize*blur,0.0, x) - smoothstep(lineSize, lineSize + lineSize*blur, x);",
			"vec3 linecol = mix(black, c, f);",
			"vec3 fragcol = mix(linecol + dotcol, black, -vNoiseDisp );",
			"gl_FragColor = vec4(fragcol, opacity);",
			"}"

		].join("\n")
};
